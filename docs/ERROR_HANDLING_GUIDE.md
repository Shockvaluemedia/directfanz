# Error Handling Guide\n\nThis document provides comprehensive guidance on error handling within the Direct Fan Platform. Our unified error handling system ensures consistent, maintainable, and user-friendly error management across the entire application.\n\n## Table of Contents\n\n1. [Overview](#overview)\n2. [Architecture](#architecture)\n3. [API Error Handling](#api-error-handling)\n4. [Client-Side Error Handling](#client-side-error-handling)\n5. [Error Monitoring](#error-monitoring)\n6. [Migration Guide](#migration-guide)\n7. [Best Practices](#best-practices)\n8. [Troubleshooting](#troubleshooting)\n\n## Overview\n\n### Key Features\n\n- **Unified Error Types**: Consistent error structure across API and client\n- **Automatic Error Classification**: Errors are automatically categorized by type and severity\n- **Context-Aware Logging**: Rich error context for debugging\n- **User-Friendly Messages**: Different messages for users vs developers\n- **Monitoring Integration**: Built-in support for error reporting services\n- **Request Tracking**: Every request gets a unique ID for debugging\n- **Development vs Production**: Different error detail levels for different environments\n\n### Error Flow\n\n`\nError Occurs → Normalization → Classification → Logging → User Response → Monitoring\n`\n\n## Architecture\n\n### Core Components\n\n1. **Error Types** (`src/lib/errors.ts`)\n - `AppError` class with structured error codes\n - User-friendly message mapping\n - Error severity classification\n\n2. **API Error Handler** (`src/lib/api-error-handler.ts`)\n - Unified API route wrappers\n - Request context management\n - Response standardization\n\n3. **Client Error Handler** (`src/lib/client-error-handler.ts`)\n - React error handling utilities\n - Toast notifications\n - Form validation helpers\n\n4. **Error Monitoring** (`src/lib/error-monitoring.ts`)\n - Integration with monitoring services\n - Performance metrics\n - Error reporting\n\n5. **Error Boundaries** (`src/components/ErrorBoundary.tsx`)\n - React error boundaries\n - Fallback components\n - Error recovery\n\n## API Error Handling\n\n### Basic Usage\n\n`typescript\nimport { withAuthenticatedApiHandler, validateApiRequest, ApiRequestContext } from '@/lib/api-error-handler';\nimport { AppError, ErrorCode } from '@/lib/errors';\nimport { z } from 'zod';\n\nconst schema = z.object({\n  title: z.string().min(1, 'Title is required'),\n  email: z.string().email('Invalid email format'),\n});\n\nexport const POST = withAuthenticatedApiHandler(\n  async (context: ApiRequestContext, userId: string, userRole: string, request: NextRequest) => {\n    // Parse and validate request\n    const body = await request.json();\n    const data = validateApiRequest(schema, body, context);\n    \n    // Business logic with proper error throwing\n    if (userRole !== 'ADMIN') {\n      throw new AppError(\n        ErrorCode.FORBIDDEN,\n        'Admin access required',\n        403,\n        { requiredRole: 'ADMIN', userRole },\n        context.requestId,\n        userId\n      );\n    }\n    \n    // Database operations (errors handled automatically)\n    const result = await prisma.user.create({ data });\n    \n    // Return success (automatically wrapped in StandardApiResponse)\n    return result;\n  }\n);\n`\n\n### API Handler Types\n\n#### 1. Basic API Handler\n\n`typescript\nimport { withApiHandler } from '@/lib/api-error-handler';\n\nexport const GET = withApiHandler(\n  async (context: ApiRequestContext) => {\n    // No authentication required\n    return { message: 'Public data' };\n  }\n);\n`\n\n#### 2. Authenticated API Handler\n\n`typescript\nimport { withAuthenticatedApiHandler } from '@/lib/api-error-handler';\n\nexport const GET = withAuthenticatedApiHandler(\n  async (context: ApiRequestContext, userId: string, userRole: string) => {\n    // User is automatically authenticated\n    return { userId, role: userRole };\n  }\n);\n`\n\n#### 3. Role-Specific Handlers\n\n`typescript\nimport { withAdminApiHandler, withArtistApiHandler } from '@/lib/api-error-handler';\n\n// Admin only\nexport const GET = withAdminApiHandler(\n  async (context: ApiRequestContext, userId: string) => {\n    // User is automatically verified as admin\n    return await getAdminData();\n  }\n);\n\n// Artist only\nexport const POST = withArtistApiHandler(\n  async (context: ApiRequestContext, userId: string) => {\n    // User is automatically verified as artist\n    return await createArtistContent(userId);\n  }\n);\n`\n\n### Error Response Format\n\nAll API responses follow the `StandardApiResponse` format:\n\n`typescript\ninterface StandardApiResponse<T = any> {\n  success: boolean;\n  data?: T;                    // Present on success\n  error?: {                   // Present on error\n    code: string;\n    message: string;\n    details?: any;            // Development only\n    timestamp: string;\n  };\n  requestId: string;\n  timestamp: string;\n}\n`\n\n### Custom Error Types\n\n`typescript\nimport { AppError, ErrorCode } from '@/lib/errors';\n\n// Throw custom errors\nthrow new AppError(\n  ErrorCode.VALIDATION_ERROR,\n  'Custom validation message',\n  400,\n  { field: 'email', value: 'invalid-email' },\n  context.requestId,\n  userId\n);\n\n// Or use predefined creators\nimport { \n  createValidationError, \n  createNotFoundError, \n  createPaymentError \n} from '@/lib/errors';\n\nthrow createValidationError('Email is required', { field: 'email' }, requestId, userId);\nthrow createNotFoundError('User not found', { userId }, requestId, userId);\nthrow createPaymentError('Payment failed', { stripeError }, requestId, userId);\n`\n\n## Client-Side Error Handling\n\n### React Hook Usage\n\n`typescript\nimport { useErrorHandler } from '@/components/ErrorBoundary';\n\nfunction MyComponent() {\n  const { handleError, handleApiError, apiCall } = useErrorHandler();\n  \n  const handleSubmit = async (data: FormData) => {\n    // Option 1: Handle API call with automatic error handling\n    const result = await apiCall(async () => {\n      return fetch('/api/submit', {\n        method: 'POST',\n        body: JSON.stringify(data),\n      }).then(res => res.json());\n    });\n    \n    if (result) {\n      // Success\n      console.log('Success:', result);\n    }\n    \n    // Option 2: Manual error handling\n    try {\n      const response = await fetch('/api/submit', {\n        method: 'POST',\n        body: JSON.stringify(data),\n      });\n      const result = await response.json();\n      \n      if (!result.success) {\n        handleApiError(result);\n        return;\n      }\n      \n      // Success\n    } catch (error) {\n      handleApiError(error);\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      {/* Form content */}\n    </form>\n  );\n}\n`\n\n### Error Boundaries\n\n#### Page Level\n\n`tsx\nimport { PageErrorBoundary } from '@/components/ErrorBoundary';\n\nfunction MyPage() {\n  return (\n    <PageErrorBoundary>\n      <MyPageContent />\n    </PageErrorBoundary>\n  );\n}\n`\n\n#### Feature Level\n\n`tsx\nimport { FeatureErrorBoundary } from '@/components/ErrorBoundary';\n\nfunction UserProfile() {\n  return (\n    <FeatureErrorBoundary featureName=\"UserProfile\">\n      <ProfileForm />\n      <ProfilePicture />\n    </FeatureErrorBoundary>\n  );\n}\n`\n\n#### Component Level\n\n`tsx\nimport { withErrorBoundary } from '@/components/ErrorBoundary';\n\nfunction MyComponent() {\n  return <div>Component content</div>;\n}\n\nexport default withErrorBoundary(MyComponent, {\n  name: 'MyComponent',\n  level: 'component'\n});\n`\n\n### Form Validation\n\n`tsx\nimport { useErrorHandler } from '@/components/ErrorBoundary';\n\nfunction LoginForm() {\n  const { handleValidationError } = useErrorHandler();\n  const [errors, setErrors] = useState<Record<string, string>>({});\n  \n  const handleSubmit = async (data: LoginData) => {\n    try {\n      await loginUser(data);\n    } catch (error) {\n      const validationError = handleValidationError(error);\n      if (validationError.field) {\n        setErrors({ [validationError.field]: validationError.message });\n      }\n    }\n  };\n  \n  return (\n    <form onSubmit={handleSubmit}>\n      <input name=\"email\" />\n      {errors.email && <span className=\"error\">{errors.email}</span>}\n    </form>\n  );\n}\n`\n\n## Error Monitoring\n\n### Setup\n\n`typescript\nimport { ErrorMonitoring } from '@/lib/error-monitoring';\n\n// Initialize in your app startup\nErrorMonitoring.init({\n  environment: process.env.NODE_ENV,\n  release: process.env.APP_VERSION,\n});\n\n// Set user context when user logs in\nErrorMonitoring.setUserContext(userId, {\n  email: user.email,\n  role: user.role,\n});\n`\n\n### Manual Error Reporting\n\n`typescript\nimport { ErrorMonitoring } from '@/lib/error-monitoring';\nimport { AppError, ErrorCode } from '@/lib/errors';\n\n// Report custom errors\nconst error = new AppError(\n  ErrorCode.EXTERNAL_SERVICE_ERROR,\n  'Stripe payment failed',\n  503,\n  { stripeError: 'card_declined' }\n);\n\nErrorMonitoring.reportError(error, {\n  userId: 'user123',\n  requestId: 'req456',\n  tags: { feature: 'payment' },\n  extra: { paymentAmount: 1999 }\n});\n\n// Report performance metrics\nErrorMonitoring.reportPerformanceMetric(\n  'api.payment.duration',\n  1500,\n  'ms',\n  { method: 'POST', status: 'success' }\n);\n`\n\n## Migration Guide\n\n### Step 1: Update API Routes\n\n**Before:**\n`typescript\nexport async function GET(request: NextRequest) {\n  try {\n    const session = await getServerSession(authOptions);\n    if (!session) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n    \n    const data = await fetchData();\n    return NextResponse.json({ data });\n  } catch (error) {\n    console.error('Error:', error);\n    return NextResponse.json({ error: 'Internal error' }, { status: 500 });\n  }\n}\n`\n\n**After:**\n`typescript\nexport const GET = withAuthenticatedApiHandler(\n  async (context: ApiRequestContext, userId: string) => {\n    const data = await fetchData();\n    return data; // Automatically wrapped in success response\n  }\n);\n`\n\n### Step 2: Update Client Components\n\n**Before:**\n`tsx\nfunction MyComponent() {\n  const [error, setError] = useState('');\n  \n  const handleAction = async () => {\n    try {\n      await doSomething();\n    } catch (err) {\n      setError('Something went wrong');\n      console.error(err);\n    }\n  };\n  \n  return (\n    <div>\n      {error && <div className=\"error\">{error}</div>}\n      <button onClick={handleAction}>Action</button>\n    </div>\n  );\n}\n`\n\n**After:**\n`tsx\nfunction MyComponent() {\n  const { apiCall } = useErrorHandler();\n  \n  const handleAction = async () => {\n    const result = await apiCall(async () => {\n      return doSomething();\n    });\n    \n    if (result) {\n      // Handle success\n    }\n    // Errors handled automatically with toast notifications\n  };\n  \n  return (\n    <button onClick={handleAction}>Action</button>\n  );\n}\n`\n\n### Step 3: Add Error Boundaries\n\n`tsx\n// Wrap your pages\nfunction MyPage() {\n  return (\n    <PageErrorBoundary>\n      <MyPageContent />\n    </PageErrorBoundary>\n  );\n}\n\n// Wrap your features\nfunction MyFeature() {\n  return (\n    <FeatureErrorBoundary featureName=\"MyFeature\">\n      <FeatureContent />\n    </FeatureErrorBoundary>\n  );\n}\n`\n\n## Best Practices\n\n### 1. Error Classification\n\n- Use appropriate error codes for different scenarios\n- Consider the user's perspective when writing error messages\n- Include helpful context for debugging without exposing sensitive data\n\n`typescript\n// Good\nthrow new AppError(\n  ErrorCode.FORBIDDEN,\n  'You need to be subscribed to access this content',\n  403,\n  { requiredTier: 'premium', userTier: 'free' },\n  requestId,\n  userId\n);\n\n// Avoid\nthrow new Error('Access denied');\n`\n\n### 2. Error Context\n\n- Always include relevant context for debugging\n- Use request IDs for tracing issues\n- Include user information when appropriate\n\n`typescript\n// Good\nthrow createPaymentError(\n  'Payment processing failed',\n  {\n    stripeError: error.code,\n    amount: paymentIntent.amount,\n    currency: paymentIntent.currency,\n    paymentMethod: paymentMethod.type\n  },\n  requestId,\n  userId\n);\n\n// Avoid\nthrow createPaymentError('Payment failed');\n`\n\n### 3. User Experience\n\n- Provide actionable error messages\n- Use appropriate error severity levels\n- Implement proper error recovery mechanisms\n\n`typescript\n// Good: Actionable message\nthrow new AppError(\n  ErrorCode.INVALID_FILE_TYPE,\n  'Please upload a JPEG, PNG, or GIF image. Maximum file size is 5MB.',\n  400,\n  { allowedTypes: ['image/jpeg', 'image/png', 'image/gif'], maxSize: '5MB' }\n);\n\n// Avoid: Vague message\nthrow new AppError(ErrorCode.VALIDATION_ERROR, 'Invalid file');\n`\n\n### 4. Performance Considerations\n\n- Don't log sensitive information\n- Use appropriate log levels\n- Consider the cost of error reporting in high-traffic scenarios\n\n`typescript\n// Good\nlogger.error('Database query failed', {\n  query: 'SELECT user FROM users WHERE id = ?',\n  duration: queryTime,\n  requestId\n});\n\n// Avoid\nlogger.error('Database query failed', {\n  query: 'SELECT * FROM users WHERE email = \"user@example.com\"',\n  password: userPassword // Never log sensitive data!\n});\n`\n\n### 5. Testing Error Handling\n\n`typescript\n// Test error scenarios\ndescribe('User API', () => {\n  it('should handle validation errors', async () => {\n    const response = await request(app)\n      .post('/api/users')\n      .send({ email: 'invalid-email' });\n    \n    expect(response.status).toBe(400);\n    expect(response.body.success).toBe(false);\n    expect(response.body.error.code).toBe('VALIDATION_ERROR');\n    expect(response.body.requestId).toBeDefined();\n  });\n  \n  it('should handle authorization errors', async () => {\n    const response = await request(app)\n      .get('/api/admin/users')\n      .set('Authorization', 'Bearer invalid-token');\n    \n    expect(response.status).toBe(401);\n    expect(response.body.error.code).toBe('UNAUTHORIZED');\n  });\n});\n`\n\n## Troubleshooting\n\n### Common Issues\n\n#### 1. Error Handler Not Working\n\n**Problem**: Errors not being caught by error handlers\n\n**Solution**: Make sure you're using the correct handler wrapper\n\n`typescript\n// Wrong\nexport async function GET() {\n  // This won't use error handling\n}\n\n// Right\nexport const GET = withApiHandler(async (context) => {\n  // This will use error handling\n});\n`\n\n#### 2. Error Details Not Showing in Development\n\n**Problem**: Error details are hidden even in development\n\n**Solution**: Check your NODE_ENV environment variable\n\n`bash\n# Make sure you have\nNODE_ENV=development\n`\n\n#### 3. Client Errors Not Being Caught\n\n**Problem**: Client-side errors not showing proper messages\n\n**Solution**: Make sure you're using error boundaries\n\n`tsx\n// Add error boundary at appropriate level\n<ErrorBoundary name=\"MyComponent\">\n  <MyComponent />\n</ErrorBoundary>\n`\n\n#### 4. Monitoring Not Working\n\n**Problem**: Errors not being reported to monitoring service\n\n**Solution**: Check your monitoring configuration\n\n`typescript\n// Initialize monitoring\nErrorMonitoring.init({\n  enabled: true, // Make sure it's enabled\n  environment: process.env.NODE_ENV\n});\n\n// Check environment variables\nconsole.log({\n  SENTRY_DSN: process.env.SENTRY_DSN,\n  NODE_ENV: process.env.NODE_ENV\n});\n`\n\n### Debug Mode\n\nEnable detailed error logging for debugging:\n\n`typescript\n// Add to your environment variables\nDEBUG_ERRORS=true\nLOG_LEVEL=debug\n\n// Or enable programmatically\nprocess.env.DEBUG_ERRORS = 'true';\n`\n\n### Request Tracing\n\nUse request IDs to trace errors across your application:\n\n1. Every API request gets a unique `requestId`\n2. The `requestId` is included in error responses\n3. Search your logs using the `requestId` to see the full request flow\n4. The `requestId` is also sent to monitoring services for correlation\n\n`bash\n# Search logs by request ID\ngrep \"req_123456789\" application.log\n\n# Or in your logging service\nrequestId:\"req_123456789\"\n`\n\n---\n\n## Support\n\nIf you encounter issues with error handling:\n\n1. Check this documentation first\n2. Look for similar issues in the codebase\n3. Check the error logs with request ID\n4. Create an issue with:\n - Request ID (if available)\n - Error message\n - Steps to reproduce\n - Expected vs actual behavior\n\n## Contributing\n\nWhen adding new error types:\n\n1. Add the error code to `ErrorCode` enum\n2. Add user-friendly message to `getUserFriendlyMessage`\n3. Add severity mapping if needed\n4. Update this documentation\n5. Add tests for the new error scenarios\n\nWhen modifying error handling:\n\n1. Ensure backward compatibility\n2. Update relevant documentation\n3. Test both development and production scenarios\n4. Verify monitoring integration works\n5. Check that error boundaries still function correctly
